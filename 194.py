# author: fanchuangwater@gmail.com
# date: 2020/3/25 下午3:26
# 目的:

from collections import deque

"""
白话：每次走到一个是 1 的点，就深度搜索它，怎么搜呢？与一个点相连的点就是 上下左右，
就搜索这 4 个点（当然需要加边界条件，如果没有 4 个相邻点呢），搜到的点就把它标记改了，反正改成不是 1 的东西就行，就是为了之后的遍历不能再把搜到的点算成新的岛屿。
那么现在思路就很清晰了.

['1', '1', '0', '0', '0']
['1', '1', '0', '0', '0']
['0', '0', '1', '0', '0']
['0', '0', '0', '1', '1']

['1', '1', '1', '1', '0']
['1', '1', '0', '1', '0']
['1', '1', '0', '0', '0']
['0', '0', '0', '0', '0']
"""



# grid = [["1","1","1","1","0"],["1","1","0","1","0"],["1","1","0","0","0"],["0","0","0","0","0"]]
# grid = [["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]
# grid = [["1","1","1"],["0","1","0"],["1","1","1"]]

grid = [["1","1","1","1","1","0","1","1","1","1","1","1","1","1","1","0","1","0","1","1"],["0","1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","0"],["1","0","1","1","1","0","0","1","1","0","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","0","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","0","0","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","0","1","1","1","1","1","1","0","1","1","1","0","1","1","1","0","1","1","1"],["0","1","1","1","1","1","1","1","1","1","1","1","0","1","1","0","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","0","1","1"],["1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["0","1","1","1","1","1","1","1","0","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","0","1","1","1","1","1","1","1","0","1","1","1","1","1","1"],["1","0","1","1","1","1","1","0","1","1","1","0","1","1","1","1","0","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","1","0"],["1","1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","0","0"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"]]

# for y in grid:
#     print(y)


visited = set()
def flood(i, j):
    stack = [(i, j)]
    while stack:
        i, j = stack.pop()
        # if (i, j) in visited:
        #     break
        # else:
        #     visited.add((i, j))


        if grid[i][j] == "1":
            grid[i][j] = "2"
        if i > 0 and grid[i-1][j] == "1":
            stack.append([i-1, j])
        if i+1 < len(grid) and grid[i + 1][j] == "1":
            stack.append([i + 1, j])
        if j > 0 and grid[i][j-1] == "1":
            stack.append([i, j-1])
        if j+1 < len(grid[i]) and grid[i][j + 1] == "1":
            stack.append([i, j + 1])
        print(stack)


ret = 0
for m in range(len(grid)):
    for n in range(len(grid[m])):
        if grid[m][n] == "1":
            flood(m, n)
            ret += 1
            print(m, n, ret)

# return ret
print(ret)

# for k in grid:
#     print(k)














# 构造四周的水，估计会比较麻烦。
# for i in range(len(grid)):
#     for j in range(len(grid[i])):
#         # print(i, j, grid[i][j])
#         # 这个是从总的情况，等于0的不考虑，先大致上过滤一下
#         if grid[i][j] == "1":
#             # 对于第一行第一列的数字。只需要跟自己比较。
#             if i == 0:
#                 if j == 0:
#                     ret += 1
#                 # 对于第一行的其他的数字需要跟自己左侧和下方的数字比较
#                 else:
#                     # 这个时候我们需要判断是否是有下一行
#                     if len(grid) > 1 and grid[i][j-1] != "1" and grid[i+1][j] != "1":
#                         ret += 1
#                     #  那么就只需要跟左侧的进行比较就行了
#                     if len(grid) <= 1 and grid[i][j-1] != "1":
#                         ret += 1
#             else:
#                 # 那么除了第一行的，剩下的　都需要跟自己左边，上面比较
#
#                 # 对于每一行的第一个数字，也是只需要跟自己的上面比较　
#                 if j == 0 and grid[i-1][j] != "1":
#                     ret += 1
#                 if j > 0 and grid[i][j-1] != "1" and grid[i-1][j] != "1":
#                     ret += 1
#
# print(ret)










