# author: fanchuangwater@gmail.com
# date: 2020/3/29 上午9:13
# 目的: 换一种思路了


grid = [[1,0,1],[0,0,0],[1,0,1]]
m = len(grid)
n = len(grid[0])
ret = 0             # 如果最终的结果是 0，说明是只有陆地或只有海洋，那就返回 -1
"""
下面这种思路，不太可行的原因是，最后进行深搜的时候，8个方向，太过复杂。
而且可能需要2个方向上的步长。由此产生了第三种思路。
"""
# 每当找到一个海洋的时候，就深搜它，检查它最近的陆地的距离。如果最下距离等于1，就停止。
for i in range(m):
    for j in range(n):

        dis = float("inf")
        if grid[i][j] == 0: # 此时需要深搜。而且是需要考虑边界的问题。

            step = 1
            while i < m and j < n:        # 这些是边界问题。    todo 边界问题需要重新修改。。。
                # 一定是先四个方向，然后才是4个角落。
                # 往左边
                if j- step >= 0 and grid[i][j-step] == 1:  # 说明我们找到了一个陆地。那么就可以操作了。
                    # 下面可以计算距离了。然后 break
                    pass



            # 假设这些边界已经给出了，那么怎么来操作呢？？
            # 检查 它 的上下左右以及4个角落总共8个方向进行搜索。取最近的。统一步长。每次都移动1

        if dis > ret:
            ret = dis

